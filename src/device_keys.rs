// Copyright 2023 Toradex A.G.
// SPDX-License-Identifier: Apache-2.0

use std::io::ErrorKind;
use std::path::Path;

use color_eyre::eyre::Context;
use ssh_key::{Algorithm, HashAlg};
use tokio::io::AsyncWriteExt;

use crate::Result;
use log::warn;

pub async fn read_or_create_pubkey(path: impl AsRef<Path>) -> Result<ssh_key::PublicKey> {
    let keypair = read_or_create(path).await?;
    Ok(keypair.public_key().clone())
}

pub async fn read_or_create(path: impl AsRef<Path>) -> Result<ssh_key::PrivateKey> {
    let path = path.as_ref();
    let key_path = tokio::fs::metadata(path).await;

    if let Err(err) = key_path {
        if err.kind() == ErrorKind::NotFound {
            let mut unencrypted_key =
                ssh_key::PrivateKey::random(&mut ssh_key::rand_core::OsRng, Algorithm::Ed25519)?;
            unencrypted_key.set_comment(format!("generated by rac on {}", chrono::Local::now()));
            let pem = unencrypted_key.to_openssh(ssh_key::LineEnding::LF)?;

            let mut file = tokio::fs::OpenOptions::new()
                .create(true)
                .write(true)
                .truncate(true)
                .mode(0o600)
                .open(path)
                .await?;

            file.write_all(pem.as_bytes()).await?;
            file.sync_all().await?;

            warn!(
                "Could not read private key, generated a new key: {}",
                unencrypted_key.fingerprint(HashAlg::default())
            );
            Ok(unencrypted_key)
        } else {
            let err: Result<ssh_key::PrivateKey> = Err(err.into());
            err.wrap_err(format!("Reading file: {path:?}"))
        }
    } else {
        let private_key = ssh_key::PrivateKey::read_openssh_file(path)?;
        Ok(private_key)
    }
}

#[allow(clippy::unwrap_used)]
#[cfg(test)]
mod test {
    use crate::test::setup;

    use ssh_key::{rand_core::OsRng, PrivateKey};

    use super::*;

    fn new_key() -> PrivateKey {
        ssh_key::PrivateKey::random(OsRng, ssh_key::Algorithm::Ed25519).unwrap()
    }

    #[tokio::test]
    async fn test_creates_key_if_missing() {
        setup();

        let file = tempfile::NamedTempFile::new().unwrap();
        let path = file.path().to_owned();
        file.close().unwrap();

        read_or_create(&path).await.unwrap();
    }

    #[tokio::test]
    async fn test_reads_key_if_exists() {
        setup();

        let file = tempfile::NamedTempFile::new().unwrap();
        let path = file.path().to_owned();
        let key = new_key();
        key.write_openssh_file(&path, ssh_key::LineEnding::LF)
            .unwrap();

        let read_key = read_or_create_pubkey(&path).await.unwrap();

        assert_eq!(*key.public_key().key_data(), *read_key.key_data());
    }
}
